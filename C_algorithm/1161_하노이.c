#include <stdio.h>
#include <stdlib.h>

void hanoi(int N, int from, int to) {
	if (N > 1) { 
		hanoi(N - 1, from, 6 - from - to); // 시작 기둥에서 중간 기둥으로 다시 옮김(재귀)
			// 세 기둥 번호가 1,2,3 일 때 1+2+3 = 6 이므로 중간 기둥은 항상 6 - from - to 가 된다. 
	}
	printf("%d : %d -> %d\n", N, from, to); // 원판 N 을 from 기둥에서 to 기둥으로 옮김 메시지 출력
	if (N > 1) {
		hanoi(N - 1, 6 - from - to, to); // 중간 기둥에서 목표 기둥으로 다시 옮김(재귀)
	}
}
// 재귀 문제 풀이 방법
// 1. 작게 쪼개기 : N = 3 만 놓고 종이에 과정을 그려보기
// 2. 부분 과정을 그려보고 맞으면 내가 아닌 함수가 한다고 생각하고 믿고 함수 작성하기
// 3. 전체 과정 중 짧은 과정을 트리와 비슷한 도식화 로 손으로 작성해보기

// 한 번에 하나의 원판만 옮길 수 있고, 큰 원판이 작은 원판 위에 있을 수 없다.
// 한 개 원판이 이동하는 과정을 line 출력으로 원판 번호 : 이동전 기둥번호 -> 이동후 기둥번호 로 모두 출력한다.
int main() {
	int N; // 1번 기둥에 쌓여 있는 원판의 개수 N (1 <= N <= 15)
	
	scanf_s("%d", &N);
	hanoi(N, 1, 3); // 총 N 개의 원판을 1번 기둥에서 3번 기둥으로 옮김

	return 0;
}